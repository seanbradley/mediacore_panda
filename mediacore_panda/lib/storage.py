# This file is a part of MediaCore-Panda, Copyright 2011 Simple Station Inc.
#
# MediaCore is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# MediaCore is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import logging
from pprint import pformat

from formencode import Invalid

from mediacore.lib.decorators import memoize
from mediacore.lib.helpers import download_uri, url_for
from mediacore.lib.i18n import N_, _
from mediacore.lib.storage import FileStorageEngine, LocalFileStorage, StorageURI, CannotTranscode
from mediacore.lib.filetypes import guess_container_format
from mediacore.lib.uri import download_uri
from mediacore.model.media import MediaFile

from mediacore_panda.lib import PandaException

PANDA_ACCESS_KEY = u'panda_access_key'
PANDA_SECRET_KEY = u'panda_secret_key'
PANDA_CLOUD_ID = u'panda_cloud_id'
PANDA_PROFILES = u'panda_profiles'
S3_BUCKET_NAME = u's3_bucket_name'
CLOUDFRONT_DOWNLOAD_URI = u'cloudfront_download_uri'
CLOUDFRONT_STREAMING_URI = u'cloudfront_streaming_uri'

from mediacore_panda.forms.admin.storage import PandaForm
from mediacore_panda.lib import PandaHelper

log = logging.getLogger(__name__)

class PandaStorage(FileStorageEngine):

    engine_type = u'PandaStorage'
    """A uniquely identifying unicode string for the StorageEngine."""

    default_name = N_(u'Panda Transcoding & Storage', domain='mediacore_panda')

    settings_form_class = PandaForm
    """Your :class:`mediacore.forms.Form` class for changing :attr:`_data`."""

    try_before = [LocalFileStorage]
    """Storage Engines that should :meth:`parse` after this class.

    This is a list of StorageEngine class objects which is used to
    perform a topological sort of engines. See :func:`sort_engines`
    and :func:`add_new_media_file`.
    """

    _default_data = {
        PANDA_ACCESS_KEY: u'',
        PANDA_SECRET_KEY: u'',
        PANDA_CLOUD_ID: u'',
        PANDA_PROFILES: [],
        S3_BUCKET_NAME: u'',
        CLOUDFRONT_DOWNLOAD_URI: u'',
        CLOUDFRONT_STREAMING_URI: u'',
    }

    @property
    @memoize
    def base_urls(self):
        s3_bucket = self._data[S3_BUCKET_NAME]
        cloudfront_http = self._data[CLOUDFRONT_DOWNLOAD_URI]
        cloudfront_rtmp = self._data[CLOUDFRONT_STREAMING_URI]
        # TODO: Return a dict or something easier to parse elsewhere
        urls = [('http', 'http://%s.s3.amazonaws.com/' % s3_bucket)]
        if cloudfront_http:
            urls.append(('http', 'http://%s/' % cloudfront_http.strip(' /')))
        else:
            urls.append((None, None))
        if cloudfront_rtmp:
            urls.append(('rtmp', 'rtmp://%s/cfx/st/' % cloudfront_rtmp.strip(' /')))
        else:
            urls.append((None, None))
        return urls

    @memoize
    def panda_helper(self):
        return PandaHelper(
            cloud_id = self._data[PANDA_CLOUD_ID],
            access_key = self._data[PANDA_ACCESS_KEY],
            secret_key = self._data[PANDA_SECRET_KEY],
        )

    def transcode(self, media_file):
        """Transcode an existing MediaFile.

        The MediaFile may be stored already by another storage engine.
        New MediaFiles will be created for each transcoding generated by this
        method.

        :type media_file: :class:`~mediacore.model.media.MediaFile`
        :param media_file: The MediaFile object to transcode.
        :raises CannotTranscode: If this storage engine can't or won't transcode the file.
        :rtype: NoneType
        :returns: Nothing
        """
        # We can't transcode our own files.
        if isinstance(media_file.storage, PandaStorage):
            return

        download_url = download_uri(media_file)
        download_url = download_url and str(download_url) or None

        if not download_url:
            log.debug('No download url!\n%s', pformat(media_file.get_uris()))
            raise CannotTranscode()

        state_update_url = url_for(
            controller='/panda/admin/media',
            action='panda_update',
            file_id=media_file.id,
            qualified=True,
        )

        panda_client = self.panda_helper().client
        response = panda_client.transcode_file(
            download_url,
            self._data[PANDA_PROFILES],
            state_update_url,
        )
        log.debug('TRANSCODE DETAILS: \n%s', pformat(response))

        panda_video_id = media_file.meta['panda_video_id'] = response.get('id', '')

        if response['status'] == 'fail':
            raise Invalid(_('Encoding failed.', domain='mediacore_panda'), None, None)

        profiles = dict((p['id'], p) for p in panda_client.get_profiles())
        encodings = panda_client.get_encodings(video_id=panda_video_id)
        encoding_files = []

        for encoding in encodings:
            log.debug('Encoding:\n %s', pformat(encoding))

            profile = profiles[encoding['profile_id']]
            extname = encoding['extname']
            if extname:
                extname = extname.lstrip('.').lower()

            file = MediaFile()
            file.container = guess_container_format(extname)
            file.display_name = '%s (%s)' \
                % (media_file.display_name, profile['name'])
            file.meta['panda_video_id'] = panda_video_id
            file.meta['panda_encoding_id'] = encoding['id']

            encoding_files.append(file)

        return encoding_files

    def get_uris(self, media_file):
        """Return a list of URIs from which the stored file can be accessed.

        :type media_file: :class:`~mediacore.model.media.MediaFile`
        :param media_file: The associated media file object.
        :rtype: list
        :returns: All :class:`StorageURI` tuples for this file.

        """
        base_urls = list(self.base_urls)

        # Skip s3 http url if cloudfront http url is available
        if base_urls[1][0]:
            base_urls = base_urls[1:]

        uris = []
        file_uri = media_file.unique_id
        for scheme, base_url in base_urls:
            if not scheme:
                continue
            uri = StorageURI(media_file, scheme, file_uri, base_url)
            uris.append(uri)
        return uris

    def delete(self, media_file):
        """Delete the stored file represented by the given unique ID.

        :type media_file: :class:`~mediacore.model.media.MediaFile`
        :param media_file: The associated media file object.
        :rtype: boolean
        :returns: True if successful, False if an error occurred.

        """
        encoding_id = media_file.meta.get('panda_encoding_id', None)
        if not encoding_id:
            log.debug('No encoding ID to delete. Huh??! %r', media_file)
            return False

        try:
            return self.panda_helper().client.delete_encoding(encoding_id)
        except PandaException, e:
            log.debug('Delete encoding exception occurred:\n%s', e)
            return False


FileStorageEngine.register(PandaStorage)
